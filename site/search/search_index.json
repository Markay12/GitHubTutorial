{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to Git and Github What is Git? Git is considered a version control system. A version control system is software that is designed the manage and track files over time. This is great for large companies and many people working on the same project. With Git you are also able to track file changes compare versions share changes combine changes This works just like a video game. When using GitHub you can just go back and create checkpoints until reaching the final version of the program. Users can create alternate versions from multiple checkpoints called \"branches\", which will be referenced later. With this, users are able to jump and compare multiple versions of the same project. One can even merge these two projects together to update or create better versions. History of Git Linus Torvalds created Linux and also created Git. He wanted to create more free software and the purpose was to have a free version control system. Now, lots of large companies use Git for their day-to-day company processes. The government has used Git to solve typos and for version control in their documents. Git can also be used for novels, screenplays and writing.","title":"Introduction to Git and Github"},{"location":"#introduction-to-git-and-github","text":"","title":"Introduction to Git and Github"},{"location":"#what-is-git","text":"Git is considered a version control system. A version control system is software that is designed the manage and track files over time. This is great for large companies and many people working on the same project. With Git you are also able to track file changes compare versions share changes combine changes This works just like a video game. When using GitHub you can just go back and create checkpoints until reaching the final version of the program. Users can create alternate versions from multiple checkpoints called \"branches\", which will be referenced later. With this, users are able to jump and compare multiple versions of the same project. One can even merge these two projects together to update or create better versions.","title":"What is Git?"},{"location":"#history-of-git","text":"Linus Torvalds created Linux and also created Git. He wanted to create more free software and the purpose was to have a free version control system. Now, lots of large companies use Git for their day-to-day company processes. The government has used Git to solve typos and for version control in their documents. Git can also be used for novels, screenplays and writing.","title":"History of Git"},{"location":"basics/","text":"","title":"GitHub Basics"},{"location":"branch/","text":"Git Branches Each commit within a branch has a hash and each commit references some parent commit that is before it. Commits have messages that detail what happened in that version of the file/project. Branches allow us to \"detach\" from this linear timeline of making changes to create our own version of the project. From here we can do whatever we want to the project without affecting the main work. If you find something that works or something you want to add, you can just bring this timeline back into the original one. The first image is a representation of the linear branch master. The second shows what it looks like when we break off into a feature branch. Master Branch The master branch is the default branch name. This is usually the most official and main branch that everyone on the project uses. The master branch is usually what is deployed/used for the final versions of a project and what the public will see. However, this does not always have to be the master branch. You can rename this branch to anything you want, or create others and get rid of it. master or main There was a push from GitHub to change the name from master branch to main branch for name convention reasons. Both are still used today and Git still uses master over main which is used by GitHub. Either of them perform the same function, however, you may notice both. What is HEAD? You will see a reference to HEAD a lot when making commits or changes to your branches with Git/GitHub. HEAD is a pointer to your current location in the repository. This is basically where you are in the timeline of the project edits. This HEAD will point to a specific branch reference and refers to a branch pointer. Branch Pointer - a reference to where a branch currently is in the timeline. It may be ahead or behind the main timeline. Viewing Branches You are able to view all branches that have been created inside a repository once created. An * will be located to the left of the branch you are currently accessing. To see this, you are going to use the command git branch -a to list all branches. Creating a New Branch To create a new branch use git branch <branch-name> . This command is just going to create the branch, this will not switch you over to the new branch right away. To switch to another branch you want to use the command git switch <branchname> . You can also create a new branch and switch to it using the switch command with git. To do this the command you use is git switch -c <branchname> This command will create the new branch based off where you are right now and then take you to the new branch. Merging Branches A branch works in its own self contained context. However, at some point we want to add the new features we coded back into the original project. To do this, you use the git merge command. The master branch is usually the source branch, so that is what is going to be used here. The 'master' branch should be the most stable and working branch in the repository. This means it is good to create a branch off of master to work on your features and once you know they work, you can add them back to the master branch. Adding these changes back to the master branch is called merging. You want to move to the receiving branch before you merge the two together. This means we want to be in the master branch before we merge the feature branch into it. Consider the two branches master and feature. We want to switch to the master branch, then merge the feature branch into this one. This type of merge is called a fast forward merge where we are not worrying about any other merges or conflicts with other people. Order of commands: git switch master git merge feature The merged branch (feature) will stay. This just updates the master branch to match the feature branch. Generate Merge Commits When doing merges, you may be missing new commits to the master branch. This starts the conversation of merge conflicts which can happen a few ways. Two people changed the same line of the master branch and try to merge in their changes. There are no conflicting changes, but lines were moved around. The second one is easier to explain and would just require a commit message for the merge to explain what changed/happened. The first is a much larger issue that is further discussed. Merge Conflicts This happens when two or more people modify the same two files in different branches and try to merge them back to the same branch. When this happens, you must decide what to keep/remove from that merge. These changes have to be made manually and a prompt will open showing you the code you must choose to keep or remove. These merge conflicts look as such... <<<<<<<<<<< HEAD My name is Mark and I like cats. =========== My name is Mark and I DO NOT LIKE cats. >>>>>>>>>>> FEATURE From here, you choose what to change and what to keep. The first message is what you have on your local file and the second one is what is uploaded to GitHub. After you know what you want to keep you remove the <<<<<<< HEAD and similar added syntax. Then you can commit and push these changes with updating the conflict. The process is as follows: Open file(s) with merge conflicts. Edit to remove conflicts. Decide what to keep and/or remove. Remove conflict markers. Add changes. Commit changes.","title":"Git Branches"},{"location":"branch/#git-branches","text":"Each commit within a branch has a hash and each commit references some parent commit that is before it. Commits have messages that detail what happened in that version of the file/project. Branches allow us to \"detach\" from this linear timeline of making changes to create our own version of the project. From here we can do whatever we want to the project without affecting the main work. If you find something that works or something you want to add, you can just bring this timeline back into the original one. The first image is a representation of the linear branch master. The second shows what it looks like when we break off into a feature branch.","title":"Git Branches"},{"location":"branch/#master-branch","text":"The master branch is the default branch name. This is usually the most official and main branch that everyone on the project uses. The master branch is usually what is deployed/used for the final versions of a project and what the public will see. However, this does not always have to be the master branch. You can rename this branch to anything you want, or create others and get rid of it.","title":"Master Branch"},{"location":"branch/#master-or-main","text":"There was a push from GitHub to change the name from master branch to main branch for name convention reasons. Both are still used today and Git still uses master over main which is used by GitHub. Either of them perform the same function, however, you may notice both.","title":"master or main"},{"location":"branch/#what-is-head","text":"You will see a reference to HEAD a lot when making commits or changes to your branches with Git/GitHub. HEAD is a pointer to your current location in the repository. This is basically where you are in the timeline of the project edits. This HEAD will point to a specific branch reference and refers to a branch pointer. Branch Pointer - a reference to where a branch currently is in the timeline. It may be ahead or behind the main timeline.","title":"What is HEAD?"},{"location":"branch/#viewing-branches","text":"You are able to view all branches that have been created inside a repository once created. An * will be located to the left of the branch you are currently accessing. To see this, you are going to use the command git branch -a to list all branches.","title":"Viewing Branches"},{"location":"branch/#creating-a-new-branch","text":"To create a new branch use git branch <branch-name> . This command is just going to create the branch, this will not switch you over to the new branch right away. To switch to another branch you want to use the command git switch <branchname> . You can also create a new branch and switch to it using the switch command with git. To do this the command you use is git switch -c <branchname> This command will create the new branch based off where you are right now and then take you to the new branch.","title":"Creating a New Branch"},{"location":"branch/#merging-branches","text":"A branch works in its own self contained context. However, at some point we want to add the new features we coded back into the original project. To do this, you use the git merge command. The master branch is usually the source branch, so that is what is going to be used here. The 'master' branch should be the most stable and working branch in the repository. This means it is good to create a branch off of master to work on your features and once you know they work, you can add them back to the master branch. Adding these changes back to the master branch is called merging. You want to move to the receiving branch before you merge the two together. This means we want to be in the master branch before we merge the feature branch into it. Consider the two branches master and feature. We want to switch to the master branch, then merge the feature branch into this one. This type of merge is called a fast forward merge where we are not worrying about any other merges or conflicts with other people. Order of commands: git switch master git merge feature The merged branch (feature) will stay. This just updates the master branch to match the feature branch.","title":"Merging Branches"},{"location":"branch/#generate-merge-commits","text":"When doing merges, you may be missing new commits to the master branch. This starts the conversation of merge conflicts which can happen a few ways. Two people changed the same line of the master branch and try to merge in their changes. There are no conflicting changes, but lines were moved around. The second one is easier to explain and would just require a commit message for the merge to explain what changed/happened. The first is a much larger issue that is further discussed.","title":"Generate Merge Commits"},{"location":"branch/#merge-conflicts","text":"This happens when two or more people modify the same two files in different branches and try to merge them back to the same branch. When this happens, you must decide what to keep/remove from that merge. These changes have to be made manually and a prompt will open showing you the code you must choose to keep or remove. These merge conflicts look as such... <<<<<<<<<<< HEAD My name is Mark and I like cats. =========== My name is Mark and I DO NOT LIKE cats. >>>>>>>>>>> FEATURE From here, you choose what to change and what to keep. The first message is what you have on your local file and the second one is what is uploaded to GitHub. After you know what you want to keep you remove the <<<<<<< HEAD and similar added syntax. Then you can commit and push these changes with updating the conflict. The process is as follows: Open file(s) with merge conflicts. Edit to remove conflicts. Decide what to keep and/or remove. Remove conflict markers. Add changes. Commit changes.","title":"Merge Conflicts"},{"location":"commit/","text":"What is a Commit? Commits are made as progress in the project is made. These are known as the checkpoints in the project. One can move between these checkpoints to manage versions in the project. Changes from multiple files and folders can be staged (added) to a new commit. The general process is... Work on Things Make Changes Commit Changes Commit's can be created, destroyed and edited. With this in mind, you can control what you actually want to commit. The command to choose what to commit is git add . From here the files that want to be committed are chosen and staged to be committed. Git Add This command is used to stage changes for committing. Files can be added, modified, deleted, then once staged, those changes are committed to that version of the project. Git commit then takes files from this staging area and creates a checkpoint. Examples of this command are git add <filename> git add . to stage all changed/updated files Git Log All commits that are made are tracked by the system and controlled. This means that you can see when and where in the process all commits are made. Creating detailed commit messages will help keep track of what the commit did and where in the version the project was at in this moment. Examples of this command are git log git log --oneline Commits in Detail Atomic Commits It is said that commits should be atomic. This means that all commits should be singular and only working on one topic and commit those features/changes. This makes rolling back previous changes much easier at a later time. Use Past or Present Tense It is generally noted that you are to use present tense when writing commit messages. Rather than writing a message that says something was added, you want to say what is happenening. Examples of this include Use: git commit README.md -m \"Add comment to readme file\" Instead of: git commit README.md -m \"Added comments to the README file\" You do want to keep in mind how your company or group does their commits. These can vary by team, but should be the same across the team structure. When doing a commit without the -m message format, you will open a general VIM editor. From here you can just change the message in the editor and write it. Git Log One of the most important ways to view your commits is with the command git log . Every time you make a commit, that commit is given a hash that allows you to revisit, delete and perform various other actions. To view this commit hash and your previous commits you can use the git log command, which looks something like this. The commit hash are the yellow lines in that photo and correspond with those commits. You can also navigate back from commits based on where the head of your project is. This uses the format HEAD~1 which goes back 1 commit from head and can change. This format will be explained later. There are far more git log commands that you can use. Just like any other command you can do git log --help to gather more information on the command. Give git log --oneline a chance! Fix Commits with Amend If you forgot to do something in your previous commit or wanted to change something you can use the amend/redo command in git. To do this we still use the git commit command but add --amend to the end of it. This is how you \"redo\" a commit. git commit --amend Ignore Files in Commit To ignore files in a git repository there is a special file to define those files. This file is the .gitignore file. The directories and files that are listed here will not be tracked by Git and GitHub. This is great when you want to secure some information or a file. Secrets/API keys will not show up if they are included in this file, which gives privacy to the comapany/creators. This also allows for package and dependency hiding if the project is not completely open source material.","title":"Git Commit"},{"location":"commit/#what-is-a-commit","text":"Commits are made as progress in the project is made. These are known as the checkpoints in the project. One can move between these checkpoints to manage versions in the project. Changes from multiple files and folders can be staged (added) to a new commit. The general process is... Work on Things Make Changes Commit Changes Commit's can be created, destroyed and edited. With this in mind, you can control what you actually want to commit. The command to choose what to commit is git add . From here the files that want to be committed are chosen and staged to be committed.","title":"What is a Commit?"},{"location":"commit/#git-add","text":"This command is used to stage changes for committing. Files can be added, modified, deleted, then once staged, those changes are committed to that version of the project. Git commit then takes files from this staging area and creates a checkpoint. Examples of this command are git add <filename> git add . to stage all changed/updated files","title":"Git Add"},{"location":"commit/#git-log","text":"All commits that are made are tracked by the system and controlled. This means that you can see when and where in the process all commits are made. Creating detailed commit messages will help keep track of what the commit did and where in the version the project was at in this moment. Examples of this command are git log git log --oneline","title":"Git Log"},{"location":"commit/#commits-in-detail","text":"","title":"Commits in Detail"},{"location":"commit/#atomic-commits","text":"It is said that commits should be atomic. This means that all commits should be singular and only working on one topic and commit those features/changes. This makes rolling back previous changes much easier at a later time.","title":"Atomic Commits"},{"location":"commit/#use-past-or-present-tense","text":"It is generally noted that you are to use present tense when writing commit messages. Rather than writing a message that says something was added, you want to say what is happenening. Examples of this include Use: git commit README.md -m \"Add comment to readme file\" Instead of: git commit README.md -m \"Added comments to the README file\" You do want to keep in mind how your company or group does their commits. These can vary by team, but should be the same across the team structure. When doing a commit without the -m message format, you will open a general VIM editor. From here you can just change the message in the editor and write it.","title":"Use Past or Present Tense"},{"location":"commit/#git-log_1","text":"One of the most important ways to view your commits is with the command git log . Every time you make a commit, that commit is given a hash that allows you to revisit, delete and perform various other actions. To view this commit hash and your previous commits you can use the git log command, which looks something like this. The commit hash are the yellow lines in that photo and correspond with those commits. You can also navigate back from commits based on where the head of your project is. This uses the format HEAD~1 which goes back 1 commit from head and can change. This format will be explained later. There are far more git log commands that you can use. Just like any other command you can do git log --help to gather more information on the command. Give git log --oneline a chance!","title":"Git Log"},{"location":"commit/#fix-commits-with-amend","text":"If you forgot to do something in your previous commit or wanted to change something you can use the amend/redo command in git. To do this we still use the git commit command but add --amend to the end of it. This is how you \"redo\" a commit. git commit --amend","title":"Fix Commits with Amend"},{"location":"commit/#ignore-files-in-commit","text":"To ignore files in a git repository there is a special file to define those files. This file is the .gitignore file. The directories and files that are listed here will not be tracked by Git and GitHub. This is great when you want to secure some information or a file. Secrets/API keys will not show up if they are included in this file, which gives privacy to the comapany/creators. This also allows for package and dependency hiding if the project is not completely open source material.","title":"Ignore Files in Commit"},{"location":"diff_stash/","text":"","title":"Git Diff and Git Stash"},{"location":"gitfiles/","text":"","title":".git Files"},{"location":"gitvgithub/","text":"Understanding Git is version control software on a machine that does not require and internet connection. GitHub hosts git repositories in the cloud so that other people can access and use your code. Git Repositories A git repository, often referred to as a repo, is a workspace which tracks and manages files in a folder. This folder has its own history, like a notebook with a table of contents. Creating a New Repository To create a new repository, one must access their own account on GitHub's site and initialize one. You will then select a name for the repository, which folder you would like to keep it in and a description for it. I would recommend that you initizalize your repo's with a README file. To access information about your repo and its files you can use the command git status in the command line. This command will give information about the current repo and its contents. To create a new repository from the command line you can use git init . This repo will be created in the same directory you are already located in. This new repository will begin with nothing in it, therefore, it is good to start with git status once created. After the initial repo has been created an initial .git folder is created. This is a hidden folder where the git configuration amongst other things is held. This folder is hidden because it holds all of the repo history. WARNING: DO NOT CREATE A REPOSITORY INSIDE A REPOSITORY","title":"Git vs. GitHub"},{"location":"gitvgithub/#understanding","text":"Git is version control software on a machine that does not require and internet connection. GitHub hosts git repositories in the cloud so that other people can access and use your code.","title":"Understanding"},{"location":"gitvgithub/#git-repositories","text":"A git repository, often referred to as a repo, is a workspace which tracks and manages files in a folder. This folder has its own history, like a notebook with a table of contents.","title":"Git Repositories"},{"location":"gitvgithub/#creating-a-new-repository","text":"To create a new repository, one must access their own account on GitHub's site and initialize one. You will then select a name for the repository, which folder you would like to keep it in and a description for it. I would recommend that you initizalize your repo's with a README file. To access information about your repo and its files you can use the command git status in the command line. This command will give information about the current repo and its contents. To create a new repository from the command line you can use git init . This repo will be created in the same directory you are already located in. This new repository will begin with nothing in it, therefore, it is good to start with git status once created. After the initial repo has been created an initial .git folder is created. This is a hidden folder where the git configuration amongst other things is held. This folder is hidden because it holds all of the repo history. WARNING: DO NOT CREATE A REPOSITORY INSIDE A REPOSITORY","title":"Creating a New Repository"},{"location":"readmefiles/","text":"","title":"README Files"},{"location":"rebasing/","text":"","title":"Rebasing"},{"location":"tags/","text":"","title":"Git Tags"},{"location":"undochange/","text":"","title":"Undoing Changes and Time Traveling"},{"location":"workflows/","text":"","title":"Workflows"}]}